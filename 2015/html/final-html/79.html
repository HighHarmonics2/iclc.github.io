<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Live Writing: Asynchronous Playback of Live Coding and Writing</title>
  <script src="jquery-1.11.3.min.js"></script>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="css/iclc.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Live Writing: Asynchronous Playback of Live Coding and Writing</h1>
<table id="authorlist"><tr>
<td>  Sang Won Lee<br />
  University of Michigan, Ann Arbor
</td>
<td>  Georg Essl<br />
  University of Michigan, Ann Arbor
</td>
</tr></table>
</div>

<h2 class="abstract">Abstract</h2>
<div id="abstract">
<p>We introduce Live Writing, asynchronous playback of a live coding performance or, more generally, writing. The concept of Live Writing is realized in a web-based application which logs every keystroke that a writer makes and let the writing later playable by the audience or the readers in real-time. The goal of Live Writing is twofold. One, it aims to support collaboration between musicians by reproducing a live coding performance based on keystroke data logged in the platform. This offers a new way for a live coder to archive live coding music and to communicate with others in asynchronous fashion. Two, it aims to transform written communication into a real-time experience so that a writer can display a writing to readers in a real-time manner as if it is being typed in front of the readers. We explain the design and the implementation of the system and demonstrate two different use cases of the system: live coding and writing.</p>
</div>

<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Live coding music is a type of written communication between human and machine expressed in programming language. At the same time, the algorithmic representation of music is a window into a composer’s thoughts. Therefore, in the case of collaborative live coding, code sharing is an important part of communication, understanding each other’s thoughts, and exchanging ideas. Most of the times, the collaboration in this live coding practice occurs in real time, due to its live nature and asynchronous communication being limited. However, being able to archive and replay live performances can further expand and enable important aspects of live coding performance culture. Benefits include the ability to (1) collaborate asynchronously, (2) incorporate last live performances into reinterpretation, reappropriation, and the creation of a persistent performance corpus. Static code is an core outcome of expressing compositional ideas that arise throughout the preparation process of a live coding performance. Nonetheless, program code itself does not represent the entire progress of the music performance. Static code does not contains temporal information of code execution nor captures a performer’s virtuosity, such as skills and techniques to utilize existing code quickly enough to make changes in the music in a timely manner. In addition, some code written on the fly may not even exist in the final code that remains after the performance. While the screen recording of a live coder’s play may capture these kinds of real-time gestures, it is fixed media in a non-symbolic format. Hence, it is impossible to get textual data from the recording so as to copy and transform, for example, someone else’s code. This calls for representations that that capture the dynamic and evolving character of live code production in a format that is readily modifiable. To this end, we developed the Live Writing platform. The Live Writing platform logs all keystrokes made by a live coder with timestamp information in order to reproduce the musician’s play later. The system can be used to archive any live coding performance ranging from individual practice to actual performances in public. The term &quot;asynchronous&quot; collaboration in &quot;live&quot; coding sounds contradictory. However, it seems potentially exciting to envision a live coding system such as one that will facilitate asynchronous collaboration. In other words, how do we utilize technologies to help a musician communicate with other musicians without needing to be present at the same time? As an extreme example, how could a live coder reproduce a piece that has been written by a live coder who has since passed away. Naturally, this poses two questions: how to notate a live coding piece and how to archive a live coder’s playing.</p>
<p>Our second goal with Live Writing is to transform, as the name suggests, general written communication into a real time experience. Writing is rich form of communication and we live in an age when we produce large volumes of writing through digital platforms such as the World Wide Web, and mobile devices. The Live Writing platform lets writers (not necessarily just live coders and artists but anyone) present their writing to readers in the same way that it was typed at the time of creation. The real-time rendering of writing gives much more expressive power to the writer and gives readers the intimacy of peeking at someone’s computer screen in private. The core idea of Live Writing is to reveal the incomplete stages of writing and of the textual dynamic as part of the written expression. For a quick demo of Live Writing, visit <a href="http://www.echobin.com/?aid=aboutechobin">http://www.echobin.com/?aid=aboutechobin</a>. A screenshot of Live Writing platform is shown in Figure 1.</p>
<div class="figure">
<img src="images/poem.png" alt="a screenshot of Live Writing example. The poem written by Pain. " /><p class="caption"><em>a screenshot of Live Writing example. The poem written by Pain. </em></p>
</div>
<p>In this paper, we introduce the background upon which the idea is built. We further motivate the core ideas, and describe the current implementation. Demonstrated on the web browser are examples in the context of live coding as well as writing. Finally, we conclude with future research opportunities offered by the system.</p>
<h1 id="asynchronous-collaboration-in-live-coding"><span class="header-section-number">2</span> Asynchronous Collaboration in Live Coding</h1>
<h2 id="live-coding-as-network-music"><span class="header-section-number">2.1</span> Live Coding as Network Music</h2>
<p>Networked communication and data sharing can facilitate collaboration among live coders. The potential of networked collaboration in live coding has been present from the inception of live coding <span class="citation">(Collins et al. 2003)</span>. <em>PowerBooks_UnPlugged</em> exemplifies an interconnected network ensemble by sharing code over a wireless network among live coders and enabling sound dislocated from the code <span class="citation">(Rohrhuber et al. 2007)</span>. Similarly, <em>aa-cell</em> added network capability to Impromptu to facilitate collaboration over the local network for sharing and executing code remotely <span class="citation">(Brown and Sorensen 2007)</span>. The scale of collaboration in live coding has reached that of an ensemble <span class="citation">(Wilson et al. 2014)</span> and a laptop orchestra <span class="citation">(Ogborn 2014c)</span>. Recently, the authors made an extension to <em>urMus</em> <span class="citation">(Essl 2010)</span>, a programming environment for mobile music, to support multiple live coders, addressing issues that emerged for collaborative live coding in general <span class="citation">(Lee and Essl 2014a)</span>.</p>
<p>In our previous work, we applied existing frameworks coming from the tradition of network music to the previous works of networked collaboration in live coding <span class="citation">(Lee and Essl 2014b)</span>. For example, we used Barbosa’s framework to classify computer-supported collaborative music based on synchronism (synchronous / asynchronous) and tele-presence (local / remote), as shown in the Figure 2 <span class="citation">(Barbosa 2003)</span>. This is used to learn opportunities in live coding and to identify relatively underdeveloped areas in the classification. Most networked live coding performances fall into the local/synchronous category, where live coders are co-located and play at the same time. Recently, researchers explored remote/synchronous collaboration in live coding music: networked live coding at Daghstuhl Seminar <span class="citation">(Swift, Gardner, and Sorensen 2014)</span>, <em>extramous</em>, language-neutral shared-buffer networked live coding system <span class="citation">(Ogborn 2014d)</span>, and <em>Gibber</em>, a live coding environment on a web browser, which supports remote code edit and run (similar to Google Doc) <span class="citation">(Roberts and Kuchera-Morin 2012)</span>. However, most previous live coding ensembles have focused on collaboration in synchronous fashion (the lower half of the chart in Figure 2).</p>
<div class="figure">
<img src="images/barbosa.png" alt="Classification Space for Network Music. Adapted after (Barbosa 2003)." /><p class="caption"><em>Classification Space for Network Music. Adapted after <span class="citation">(Barbosa 2003)</span>.</em></p>
</div>
<h2 id="music-notation-in-live-coding."><span class="header-section-number">2.2</span> Music Notation in Live Coding.</h2>
<p>In the traditional sense of music notation, where the objective is for a composer to communicate with performers in the future, the music notation for live coding is not well-established for discussion. Traditional music notation is certainly not well fitted for notating live-coded music. This is because live coding is a highly improvisational and interactive form of art where composition occurs at the time of performance; in live coding there is no clear distinction between composer and performer. Rather, a live coder is “composer-performer.”</p>
<p>Indeed, the discussion of notation in live coding has been focused on its real-time usage at the performance. In this context of real-time composition/performance, the code (either textual or graphical) serves as a music score and diverse scoring approaches as code representation have been attempted <span class="citation">(Magnusson 2011)</span>. Graphical visualization of the code is effective for better audience communication <span class="citation">(McLean et al. 2010)</span>. In addition, the real-time music notation can be a medium that connects live coding musicians and instrumental performers <span class="citation">(Lee and Freeman 2013; Hall 2014)</span>.</p>
<h2 id="archiving-a-live-coding-performance."><span class="header-section-number">2.3</span> Archiving a live coding performance.</h2>
<p>It seems that, for the time being, the music notation for live coding music with the traditional goal of documenting a piece may not need to reach a single conclusion. Instead, live coders should be able to archive live coding performances for the following benefits: i) an archive of a live coding performance can be used to exchange ideas and data with collaborators, ii) the collection of live coding pieces can be fruitful, from a long-term perspective, for the live coding community as a way to transfer knowledge, providing inspiration and developing the field for posterity.</p>
<p>One immediate solution to archive a live coding piece is to save, as electronic files, the program code that was used in the performance. However, the code alone is not enough for a live coder to document a music piece in a way that someone in the future (including oneself) would be able to repeat the performance. Static code itself cannot reproduce a live coding piece because it does not contain the performance aspects of algorithms execution. Furthermore, a certain amount of virtuosity in live coding is involved with real-time manipulation of code, which is not well exposed in the final text of the code. Practitioners use static code in combination with other tools such as audio recording, videotaping, screen recording, or open form score (e.g., textual or graphical notes) as part of the documentation in rehearsal, composition, and preparation steps of a performance.</p>
<p>Archiving a live coder’s performance will have more potential in the scenario of a live coding ensemble to support asynchronous communication among the members. At the moment, the most obvious collaboration strategy that all live coding ensembles take is a combination of rehearsals and individual practice. However, it will be practically challenging to find the time (and the place) that every member of the ensemble can participate. The problem will worsen in scale, such as in the case of a live coding orchestra <span class="citation">(Ogborn 2014c)</span>. Alternatively, each musician can do at-home practice to create new ideas for the ensemble and the individual. However, communication is delayed until the next gathering. To that end, a live coding ensemble will benefit from developing a new format of archiving a music performance, which will eventually support non real-time collaboration among members.</p>
<p>Lastly, archiving a live coding performance will enhance the composition process for a solo live coder. A live coder can log each composition session to document the progress; the archive will help the composer capture new ideas, which appear of a sudden and go away during the exploration and the improvisation.</p>
<h2 id="live-writing-documenting-and-replaying-textual-dynamics-of-live-coding"><span class="header-section-number">2.4</span> Live Writing: Documenting and Replaying Textual Dynamics of Live Coding</h2>
<p>The live coding piece performed on Live Writing platform will be logged in the keystroke levels with timestamp information so that the generative music can be reproduced by the typing simulation. Given it is sequenced data rather than fixed media, this differs from audio/video recording, and it is different from the music notation, as it can be used to capture a particular performance. It provides symbolic information, which a musician can easily copy, duplicate, and make changes to. The log file generated from Live Writing platform is analogous to a MIDI sequence file, which describes musical dynamics as an intermediate often input-centric representation. Live Writing serves a similar function in terms of capturing input-centric dynamics of text entry. Figure 3 shows the analogy between traditional music and live coding in terms of ways to archive a music performance.</p>
<div class="figure">
<img src="images/analogy.png" alt="The methods to archive music performances in traditional music and live coding. " /><p class="caption"><em>The methods to archive music performances in traditional music and live coding. </em></p>
</div>
<p>The highlight of Live Writing platform is that it provides temporal information of the live coding piece that static code cannot. Replaying the code of a piece can inform the order of code written, the timing of execution, and the virtuosic moves of a live coder, elements that would have been impossible to know in the final code. The playback feature could help transfer practical knowledge of carrying out the piece and help people practice along with collaborator’s simulated performance. The idea of Live Writing draws upon existing systems that enable asynchronous displays of code. In particular, Live Writing platform is directly inspired by <span class="citation">Ogborn (2014e)</span>’s performance using <em>Daem0n.sc</em> system, which types the text of a file automatically—in sync with the default metronome in Supercollider. <em>Gibber</em> provides a playground in which people can publish and browse <em>Gibber</em> code so that the hub supports asynchronous collaboration in a broad sense within the community <span class="citation">(Roberts et al. 2014)</span>. In <em>Threnoscope</em>, <span class="citation">Magnusson (2014)</span> introduced code snippets in a piano-roll-like notation where it is used as a secondary composition/performance interface, potentially a great archive format to document a performance on the system. In non-artistic cases, Google Wave, which is no longer available, contained the playback feature at the email transaction level so that one can understand the temporal order of email messages especially for those who got included in the conversation later. Lastly, thecodeplayer.com implements keystroke level playback of writing code but it is not currently accessible to the public to create contents<span class="citation">(“Thecodeplayer.Com”)</span>.</p>
<h2 id="beyond-archive-new-media-for-collaborative-live-coding"><span class="header-section-number">2.5</span> Beyond Archive: New Media for Collaborative Live Coding</h2>
<p>The symbolic representation of the archived performance offers novel opportunities for asynchronous collaboration among musicians. A live coder can access the code generated on the fly easily while a screencast or the final static code cannot offer such data, i.e., copy the code in the middle of the playback simulation and paste it on one’s editor to use existing code to develop ideas, and to create collaborative musical patterns. It can be used throughout the rehearsal process for a live coding ensemble to sketch ideas and exchange code over emails, and to rehearse along with the ensemble members asynchronously.</p>
<p>Keystroke log is a valuable asset for monitoring/analyzing a live coder’s performance. It is not only great for self-reflection on one’s rehearsal/performance but also a useful material to analyze a live coder’s performance. The performance log can be used to analyze live coding musicians’ play and learn complex behaviors that are not translated easily from audio, static code and the artist’s statement, for example, the virtuosity of a performer in programming and musical style. Such research has been done to create a performer’s fingerprint <span class="citation">(Swift et al. 2014)</span> and would have been expedited and enriched with the corpus of logged data accumulated in the system, otherwise, such data should be manually annotated from the screencast.</p>
<p>Lastly, supplementing visualization/navigation techniques to be implemented in the future (the navigation bar, keystroke density visualization, temporal typography) will offer an interactivity in the middle of playback of live coding. For example, a reader can pause, modify, fork or remix a performance and create a unique live coding collaboration that can occur over a long time. Forthcoming features of the Live Writing system will be discussed in detail at the end of this paper.</p>
<h1 id="written-communication-into-a-real-time-performance"><span class="header-section-number">3</span> Written Communication into a Real Time Performance</h1>
<p>In this section, we switch the context of discussion from live coding music to writing in general. First, imagine a performer going on stage and starting to write a poem (whether it is typed on a screen or written on a piece of paper, shared with the audience). The live coding community would easily call this a live writing performance and the performer would need nothing more than sheets of paper and a pen or a text editor on a laptop projected on a screen. Live Writing platform allows users to dynamically present a writing; readers can read the article as if it is being typed right in front of them. It does not necessarily need to be a synchronous performance in public but anything written in private (for example, poem, essay, instant messages, email, or tweets) can be presented as if readers were watching the writer typing in real time. The same platform that was used to archive live coding performances is repurposed for this new expressive art.</p>
<h2 id="keystroke-logging-and-playback-of-writing"><span class="header-section-number">3.1</span> Keystroke Logging and Playback of Writing</h2>
<p>The realization of Live Writing platform is to utilize keystroke logging on a computer. For a long time now, the idea of logging user input from a keyboard has been a simple but powerful research method in many different contexts. <em>Keystroke Level Model</em> (KLM) was an important aspect of research into modeling human performance in many human-computer interaction tasks <span class="citation">(Card, Moran, and Newell 1980)</span>. It was also used to analyze email organization strategy <span class="citation">(B<span>ä</span>lter 2000)</span>. Keystroke dynamic has also been used for verifying identities. Habitual temporal patterns of key entries provide a behavioral biometric useful for identifying individuals <span class="citation">(Joyce and Gupta 1990; Monrose and Rubin 2000)</span>.</p>
<p>In helping analyze real-time writing behavior, keystroke logging has become a common approach in the field of writing research. It provides a non-intrusive and inexpensive technique to monitor user inputs. Writing researchers have developed a number of keystroke logging applications—<em>Inputlog</em><span class="citation">(Leijten and Van Waes 2006)</span> and <em>ScriptLog</em><span class="citation">(Str<span>ö</span>mqvist et al. 2006)</span> are two examples of such programs. Most keystroke logging applications include real-time playback recorded keystrokes and it is an effective approach to help subjects account for their writing in retrospect, which is less intrusive than having them think aloud while writing <span class="citation">(Latif 2008)</span>. These applications are mainly for the research purpose of real-time writing analysis rather than for writing in general public.</p>
<h2 id="live-writing-writing-as-real-time-performance"><span class="header-section-number">3.2</span> Live Writing : Writing as Real-Time Performance</h2>
<p>The direct inspiration of the notion of live writing is live coding. Writing is an expressive process guided and adapted by thoughts that evolve over time. By revealing the real-time writing process to readers, Live Writing lets a writer show the thought process and the intermediate stages of the writing as it is typed, including typos, corrections, and deletions. This principle is well captured in the following statement of the <em>TOPLAP</em> manifesto: &quot;Obscurantism is dangerous. Show us your screens.&quot; We expand the same idea to writing in general. Showing the entire process of writing as it emerges sheds light on the trajectory of thoughts and provides more expressive power than when reading final text. It is analogous to revealing the thought process of a composer as a form of algorithm in live coding music.</p>
<p>The real-time rendering of writing in the same way that it was typed is certainly more expressive than static writing. There are various kinds of writer's emotional states (such as contemplation, hesitation, confidence, or agitation) that can emerge during the process of typing based on temporal patterns, for instance, pause, bursts, or corrective steps. The fact that every single entry is shown in the final outcome transforms writing in general into a creative experience in real-time, similar to musical improvisation. Indeed, such an improvisational nature is prominent on the World Wide Web, for example, vlogging, podcasting, live game streaming, and video tutorials with screen recording and voice over.</p>
<p>It may be argued that calling this “Live” Writing is somewhat misleading as the Live Writing platform enables asynchronous (that is apparently not “live”) uses. However, we hold that the very process of writing is the live act in this case, and this liveness of the writing process is captured, hence justifying the use of “live” in this context. Moreover, by explicitly capturing the the temporal dynamic of the writing process it suggests a changed mindset in the writer with respect to the meaning and performative function of the writing process itself. A writer can now ponder the arrangement of text over time and leverage the articulation of the temporal dynamics (like a composer organizing sound to make music). This can be premeditated as in compositions, or improvised. Further it suggests a deliberation of the delivery process even if the material is fixed, leading to an expressive layer of interpretation that transcends yet potentially interrelates with the text. One can see this analogous to the notion of a “live” recording. The production process is live, yet the reproduction method is not. This does by no means preclude the consideration of live writing in a fully real-time synchronous performance setting. In fact we are currently exploring synchronous live writing piece as a form of audiovisual performing arts, of which a visualization technique on typography is discussed elsewhere <span class="citation">(Lee and Essl 2015)</span>.</p>
<h1 id="design-and-implementation"><span class="header-section-number">4</span> Design and Implementation</h1>
<p>Live Writing is implemented as a web application in order to be easily accessible from a variety of platforms and devices. The web browser is chosen to make the platform language neutral (as long as the live coding language is textual). In addition, the web browser is one of the most popular writing platforms today. Many live coding language environments allows the editing part to be separated from the local machine and to reside on the web browser or web-based editors (such as Atom, Sublime Text, or Brackets I/O). This would work, of course, for live coding languages built into the web browser. We realize this system cannot support many live coders who use other popular editors (e.g. emacs). However, we chose the web browser given it is a good platform-independent application and the use of web browser is on the increase in live coding. Eventually, modern web-based editing APIs such as CodeMirror and ACE have been and will be evolving to support many functions like shortcuts and macro to replace such editors or the Live Writing feature can be easily implemented in across multiple editing environments if needed. It should be addressed that the system will be limited to textual live coding languages but the idea can be extended to graphical languages.</p>
<p>The API is designed to extend existing an html object &lt;textarea&gt; or code editing APIs (e.g. codemirror, ace) so that it can easily extend existing systems on the web browsers. In the following section, the implementation of the application for the writing purpose is described first. Demonstrated later in this section is an archiving and playback example built on top of <em>Gibber</em>.</p>
<h2 id="live-writing-app-for-written-communication"><span class="header-section-number">4.1</span> Live Writing App for Written Communication</h2>
<p>For the writing purpose of Live Writing, the application is publically available for anyone to use <a href="http://www.echobin.com/">http://www.echobin.com/</a>. The current implementation is crafted with minimal design; it has only one clean slate, an initial dialog with brief description, screen-sized &lt;textarea&gt; objects, and a few buttons hidden on the side (see Figure 1). Once a user presses the start button, all keystrokes and mouse cursor clicks made inside the &lt;textarea&gt; will be recorded on the local machine. And then, by pressing the post button on the right side, the user can post the piece of writing. Once the data is posted, the user is given the link that accesses the real-time playback of the writing. The link contains the article ID and anyone with the link can view the playback of the writing. Therefore, access control of the writing is up to the writer and whom he or she chooses to share the link with, an action that can be easily done via email, a facebook post, or instant messages.</p>
<p>The web application is realized in javascript/jQuery/AJAX and node.js. We released the code as an open-source API so that any html &lt;textarea&gt; can be extended to feature keystroke logging and playback by including one javascript file. The server runs node.js script which handles the static files and store/retrieve recorded keystrokes log in json format. All the other functions of keystroke logging and playback is implemented and run in the client machine which the writer uses. The logged data is not stored in the server until the user chooses to post the writing. Alternatively, a user can choose to download the log file instead of posting to the server, if the user wants to keep the logged data locally. Anyone who has the log file will be able, by uploading the file, to replay the writing. Providing raw data in the file will be useful for extracting high-level information such as keystroke dynamics or behavioral pattern when processed. We hope that this supports researchers wanting to use this as a keystroke-logging application.</p>
<p>To implement playback, the keystrokes logged are simulated by specifically reproducing what the keystroke would change in the content of &lt;textarea&gt;. In other words, a web browser does not allow, for security reasons, javascript to generate the exact same keystroke event. Instead, for example, to reproduce a user's pressing of the “s” key, it has to append the “s” character to where the cursor is in the &lt;textarea&gt; at the moment. Note that the &lt;textarea&gt; used in keystroke logging is again used for playback. Improvements to the website are in progress so that a user can customize the writing not only visually (font type, size etc.) but also through its playback setting (e.g.,, playback speed, navigation across time, etc.).</p>
<h2 id="playback-of-live-coding-gibber-code-on-codemirror"><span class="header-section-number">4.2</span> Playback of live coding : <em>Gibber</em> code on <em>codemirror</em></h2>
<p>To demonstrate the archiving and replaying features of Live Writing, this study has chosen <em>Gibber</em> <span class="citation">(Roberts and Kuchera-Morin 2012)</span>, a live coding environment on a web browser. It could have been possible to create the same features with other live coding languages (e.g., Supercollider) that can be edited on a web browser and communicated with the live coding engine by sending textual data to the localhost. Because <em>Gibber</em> is built into the web browser, it makes the demo accessible to public without any configuration and installation. Lastly, for the code-editing environment, the study uses <em>Codemirror</em> <span class="citation">(Haverbeke 2011)</span>. Codemirror comes with a set of features readily available for programming (e.g., syntax highlighting, keymap binding, autocomplete).</p>
<p>The user experience in the <em>Gibber</em> demo is similar to that of the writing web application introduced above. In terms of implementation, however, a few differences from the writing scenario should be noted. This uses high-level events (onchange, cursor activity) supported from codemirror instead of low-level events (e.g., keyUp, keyDown, keyPress) in &lt;textarea&gt;. In addition, the pressing of shortcut keys related to code execution (Ctrl-Enter, Ctrl-.) is separately stored as a message so that simulated typing will trigger a code run to get audiovisual outcome while playback. The working demo is available at <a href="http://www.echobin.com/gibber.html">http://www.echobin.com/gibber.html</a>. For a simple playback demo without entering Gibber code, visit <a href="http://www.echobin.com/gibber.html?aid=OKDMWHgkDCdAmA">http://www.echobin.com/gibber.html?aid=OKDMWHgkDCdAmA</a> which shows the demo captured in Figure 4.</p>
<div class="figure">
<img src="images/gibber_demo.png" alt="Screen captures of Gibber Demo Audiovisual outcome generated automatically by playback of Gibber code over time (from left to right). This demo is available at http://www.echobin.com/gibber.html?aid=OKDMWHgkDCdAmA" /><p class="caption"><em>Screen captures of Gibber Demo Audiovisual outcome generated automatically by playback of Gibber code over time (from left to right). This demo is available at <a href="http://www.echobin.com/gibber.html?aid=OKDMWHgkDCdAmA">http://www.echobin.com/gibber.html?aid=OKDMWHgkDCdAmA</a></em></p>
</div>
<h1 id="conclusion"><span class="header-section-number">5</span> Conclusion</h1>
<p>In this paper, we have introduced Live Writing, a web-based application which enables keystroke logging for real-time playback of the writing. The motivation for this idea is to facilitate asynchronous collaboration among live coders and to archive a live coding performance in an informative way. Additionally, the Live Writing platform is repurposed for general written communication and has potentially turned a writing activity into a live coding like performance.</p>
<p>There are a number of directions that we can take for future research. We plan to integrate Live Writing editor with existing live coding environments and evaluate the usage of features in practice. It would be desirable to investigate the system usage in a collaboration scenario like live coding ensemble. On the other hand, with the features of playback, we would be able to build a live coding gallery in which users publish their piece and people can enjoy the live coding piece remotely and asynchronously. In addition, we want to make the playback feature not interfere with key entry so that a spectator can write text while keystrokes are replayed. This will create unique opportunities in a crowd-sourced music piece that grows over time by people’s participation in a system that is similar to github.</p>
<p>Another ongoing effort is to explore the idea of live writing and to deliver a live-writing performance and a participatory audiovisual art on a web browser. Currently, temporal typography based on a web browser is in development to augment the text editor with animated fonts <span class="citation">(Lee and Essl 2015)</span>. It will afford novel ways of visualizing text in combination with music and algorithms, associated with the content of writing. To explore the idea of live-writing poetry, an audiovisual piece is in preparation for a public concert. In addition, visualization of the text will be used to visualize the program state as well as music in the context of live coding.</p>
<p>Lastly, the Live Writing application will be further developed for general programming and evaluated in terms of human-computer interaction. We believe that the playback feature of the editor will attract programmers to use the editor for numerous reasons (self-evaluation, fine-grained version control, online tutorial, collaboration, programming challenge/interviews). Improvement of the editor in progress includes the navigation bar, typing density visualization, and automated summary. The collection of source code published to the server can be used to mine valuable information (i.e., temporal progress of good/bad coding style) in the context of software engineering and pedagogy in computer science</p>

<div class="references">
<p>B<span>ä</span>lter, Olle. 2000. “Keystroke Level Analysis of Email Message Organization.” In <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em>, 105–112. ACM.</p>
<p>Barbosa, <span>Á</span>lvaro. 2003. “Displaced Soundscapes: a Survey of Network Systems for Music and Sonic Art Creation.” <em>Leonardo Music Journal</em> 13: 53–59.</p>
<p>Brown, Andrew R, and Andrew C Sorensen. 2007. “Aa-Cell in Practice: an Approach to Musical Live Coding.” In <em>Proceedings of the International Computer Music Conference</em>, 292–299. International Computer Music Association.</p>
<p>Card, Stuart K, Thomas P Moran, and Allen Newell. 1980. “The Keystroke-Level Model for User Performance Time with Interactive Systems.” <em>Communications of the ACM</em> 23 (7): 396–410.</p>
<p>Collins, Nick, Alex. McLean, Julian. Rohrhuber, and Adrian. Ward. 2003. “Live Coding in Laptop Performance.” <em>Organised Sound</em> 8 (03): 321–330.</p>
<p>Essl, G. 2010. “UrMus – An Environment for Mobile Instrument Design and Performance.” In <em>Proceedings of the International Computer Music Conference (ICMC)</em>. Stony Brooks/New York.</p>
<p>Hall, Tom. 2014. “Live Digital Notations for Collaborative Music Performance.” In <em>Proceedings of the Live Coding and Collaboration Symposium 2014</em>. Birmingham, United Kingdom.</p>
<p>Haverbeke, M. 2011. “Codemirror.” <a href="http://codemirror.net/">http://codemirror.net/</a>.</p>
<p>Joyce, Rick, and Gopal Gupta. 1990. “Identity Authentication Based on Keystroke Latencies.” <em>Communications of the ACM</em> 33 (2): 168–176.</p>
<p>Latif, Muhammad M Abdel. 2008. “A State-of-the-Art Review of the Real-Time Computer-Aided Study of the Writing Process.” <em>IJES, International Journal of English Studies</em> 8 (1): 29–50.</p>
<p>Lee, Sang Won, and Georg Essl. 2014a. “Communication, Control, and State Sharing in Collaborative Live Coding.” In <em>Proceedings of New Interfaces for Musical Expression (NIME)</em>. London, United Kingdom.</p>
<p>———. 2014b. “Models and Opportunities for Networked Live Coding.” In <em>Proceedings of the Live Coding and Collaboration Symposium 2014</em>. Birmingham, United Kingdom.</p>
<p>———. 2015. “Web-Based Temporal Typography for Musical Expression and Performance.” In <em>Proceedings of New Interfaces for Musical Expression (NIME)</em>. Baton Rouge, United States.</p>
<p>Lee, Sang Won, and Jason Freeman. 2013. “Real-Time Music Notation in Mixed Laptop–Acoustic Ensembles.” <em>Computer Music Journal</em> 37 (4): 24–36.</p>
<p>Leijten, Mari<span>ë</span>lle, and Luuk Van Waes. 2006. “Inputlog: New Perspectives on the Logging of on-Line Writing Processes in a Windows Environment.” <em>Studies in Writing</em> 18: 73.</p>
<p>Magnusson, Thor. 2011. “Algorithms as Scores: Coding Live Music.” <em>Leonardo Music Journal</em> 21: 19–23.</p>
<p>———. 2014. “Improvising with the Threnoscope: Integrating Code, Hardware, GUI, Network, and Graphic Scores.” In NIME.</p>
<p>McLean, A., D. Griffiths, N. Collins, and G. Wiggins. 2010. “Visualisation of Live Code.” <em>Proceedings of Electronic Visualisation and the Arts 2010</em>.</p>
<p>Monrose, Fabian, and Aviel D Rubin. 2000. “Keystroke Dynamics as a Biometric for Authentication.” <em>Future Generation Computer Systems</em> 16 (4): 351–359.</p>
<p>Ogborn, David. 2014c. “Live Coding in a Scalable, Participatory Laptop Orchestra.” <em>Computer Music Journal</em> 38 (1): 17–30.</p>
<p>———. 2014d. “Extramuros.” <a href="https://github.com/d0kt0r0/extramuros">https://github.com/d0kt0r0/extramuros</a>.</p>
<p>———. 2014e. “Daem0n.” <a href="https://github.com/d0kt0r0/Daem0n.sc">https://github.com/d0kt0r0/Daem0n.sc</a>.</p>
<p>Roberts, C., and J.A. Kuchera-Morin. 2012. “Gibber: Live Coding Audio in the Browser.” In <em>Proceedings of the International Computer Music Conference (ICMC)</em>. Ljubljana, Slovenia.</p>
<p>Roberts, Charles, Matthew Wright, J Kuchera-Morin, and Tobias H<span>ö</span>llerer. 2014. “Rapid Creation and Publication of Digital Musical Instruments.” In <em>Proceedings of New Interfaces for Musical Expression</em>.</p>
<p>Rohrhuber, Julian, Alberto de Campo, Renate Wieser, Jan-Kees van Kampen, Echo Ho, and Hannes H<span>ö</span>lzl. 2007. “Purloined Letters and Distributed Persons.” In <em>Music in the Global Village Conference (Budapest)</em>.</p>
<p>Str<span>ö</span>mqvist, Sven, Kenneth Holmqvist, Victoria Johansson, Henrik Karlsson, and <span>Å</span>sa Wengelin. 2006. “What Keystroke-Logging Can Reveal About Writing.” <em>Computer Key-Stroke Logging and Writing: Methods and Applications (Studies in Writing)</em> 18: 45–72.</p>
<p>Swift, Ben, Henry Gardner, and Andrew Sorensen. 2014. “Networked Livecoding at VL/HCC 2013.” In <em>Visual Languages and Human-Centric Computing (VL/HCC), 2014 IEEE Symposium on</em>, 221–222. IEEE.</p>
<p>Swift, Ben, Andrew Sorensen, Michael Martin, and Henry Gardner. 2014. “Coding Livecoding.” In <em>Proceedings of the 32nd Annual ACM Conference on Human Factors in Computing Systems</em>, 1021–1024. ACM.</p>
<p>“Thecodeplayer.Com.” <a href="http://thecodeplayer.com">http://thecodeplayer.com</a>.</p>
<p>Wilson, Scott, Norah Lorway, Rosalyn Coull, Konstantinos Vasilakos, and Tim Moyers. 2014. “Free as in BEER: Some Explorations into Structured Improvisation Using Networked Live-Coding Systems.” <em>Computer Music Journal</em> 38 (1): 54–64.</p>
</div>
</body>
</html>
