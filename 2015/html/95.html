<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Live Patch / Live Code</title>
  <script src="jquery-1.11.3.min.js"></script>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="css/iclc.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Live Patch / Live Code</h1>
<table id="authorlist"><tr>
<td>  Charles Celeste HUTCHINS<br />
  University of Kent
</td>
</tr></table>
</div>

<h2 class="abstract">Abstract</h2>
<div id="abstract">
<p>Modular synthesiser live-patching has gradually been accepted into the big-tent of live coding practice, due to a number of natural similarities to computer-based live coding. These similarities especially include flexibility, complexity and sudden stops. In my own performance of live-patching, I have sought out other areas of digital live coding practice to apply to the modular synthesiser. These include starting from a blank slate, showing my cables (sometimes with projection), graph changes and the use of conditional triggers to create audio events.</p>
</div>

<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>The definition of live code has been gradually growing over the years of contemporary practice. In 2008, McLean struggled to name any non-digital live coding practice. <span class="citation">(McLean 2008)</span> Then, in February 2011, there was a very brief discussion on the TopLap email list as to whether live patching modular synthesisers was an analogue form of live coding <span class="citation">(Rohrhuber 2001)</span>. By June of that year, Nick Collins was treating the question as settled in <em>Leonardo</em>, listing live electronics band Loud Objects as an example of live coding. <span class="citation">(Collins 2011)</span> He notes, when talking about live algorithms, 'Computers remain a primary touching point, but let us also keep in sight examples that center on human rule-making independent of digital computability.' <span class="citation">(Collins 2011)</span> Given this very broad potential pool of music-making activity, live coding has become extremely inclusive. Thor Magnusson referred to 'herding cats' in the title of one his papers, as a reference to this wide diversity. <span class="citation">(Magnusson 2014)</span> Indeed, I heard a joke recently that it would be faster to make a list of all the things that <em>aren't</em> live coding, rather than the things that are.</p>
<h1 id="synthesiser-as-a-live-code-platform"><span class="header-section-number">2</span> Synthesiser as a Live Code Platform</h1>
<p>Given how open live coding has become, it may become useful to discuss points of commonality between divergent live coding practices. In many ways, live synthesiser patching seems different from live coding with a computer, given the vastly different interface. There is a greater amount of tactility, which, to me at least, feels closer to playing a traditional musical instrument than creating an algorithm. It is also worth noting that the synthesiser is specifically designed for music making, unlike a computer, and thus has a limit on the kinds of operations and calculations it can do. In this way, a synthesiser is both a chainsaw and an idea. <span class="citation">(TopLap 2010)</span></p>
<p>Thus chainsaws vs ideas become less of a binary opposition and more a continuum. Tools, such as chainsaws, are perceived as extensions of the body of the user. <span class="citation">(Cardinali et al. 2009)</span> My experience of playing the tuba very much matches this. By contrast, my experience of text-based computer live coding feels abstract and unembodied. Live-patching the synthesiser lies in between. The afore-mentioned tactility does give it some feelings of embodiment. But plugging in cables and deciding how to route signals primarily involves abstract decision-making. Playing a patch, therefore, is chainsaw-like. Making the patch is idea-like.</p>
<h2 id="commonality"><span class="header-section-number">2.1</span> Commonality</h2>
<p>A modular synthesiser, therefore has many points of similarity with digital live coding practice. The specific design of a synthesiser for only music making may not parallel computer hardware, but the specificity certainly parallels the way some live coding languages have developed. While you can't use your synthesiser to check your email, this is also impossible in several live-coding languages and with early analogue or other non-digital computers. And, indeed, the modular synthesiser does have a general purpose element within the musical sphere. Common practice, when I was an undergraduate, was to spend time in the studio, carefully making the perfect sound. This is also how I was taught to write code.</p>
<p>Historically, modular synthesisers do not seem to have been seen as live electronics systems to the same extent as were some particular pieces, such as <em>Runthrough</em> by David <span class="citation">Behrman (1971)</span>, which is realised live with DIY electronics. The programme notes for that piece state,</p>
<blockquote>
<p>No special skills or training are helpful in turning knobs or shining flashlights, so whatever music can emerge from the equipment is as available to non-musicians as to musicians . . .. Things are going well when all the players have the sensation they are riding a sound they like in harmony together, and when each is appreciative of what the others are doing <span class="citation">(Behrman 1971)</span>.</p>
</blockquote>
<p>The piece is based entirely on discovery and has no set plan or written score (ibid). The piece-ness relies on the equipment. Scot Gresham-Lancaster describes pieces like this one as “direct use of electronics as a 'score'” <span class="citation">(Gresham-Lancaster 1998)</span>.</p>
<p>Historical live electronic pieces like <em>Runthrough</em> do differ from live-patching in that a modular synthesiser is designed to be a more general purpose tool and its use does not imply a particular piece. Interestingly, however, some live coding platforms, like ixi lang, have been compared to graphic scores due to their use of space <span class="citation">(Magnusson 2011)</span> and thus do have a certain piece-ness about them. However, unlike ixi lang and <em>Runthrough</em>, understanding the interaction between synthesiser modules is not designed for ease of use for non-musicians. It is a specialist skill which does imply that expertise is possible. However, the idea of finding a sound and following it is similar to live electronics and all of these practices make use of improvisation. These are all points of commonality between live patching and digital live coding.</p>
<p>Additionally, the interface differences between modular synthesis and computer languages do not create as large a gap as it might at first seem. While synthesiser modules are not like text-based code, neither are all languages. Scheme Bricks, a live coding language by Dave <span class="citation">Griffiths (2012)</span> is an example of a coding language that relies very heavily on graphic elements rather than dense lines of text. A step closer to the synthesiser patching interface (and not uncoincidentally so) are the patching languages MAX/MSP and Pd. A version of one of these languages which had only a set and limited number of unit generators and control generators would not be logically different than a modular synthesiser. Even the model of making connections is the same.</p>
<h2 id="complexity"><span class="header-section-number">2.2</span> Complexity</h2>
<p>Both digital systems and analogue modular systems allow a user to create a graph of unit generators to generate sounds electronically. In both systems, the graphs and their control mechanisms can quickly grow in complexity, past the point where the player can easily understand what is happening. The late Click Nilson hints at this in his 2007 paper. In a footnote, he quotes a personal communication from Julian Rohrhuber, 'The main difficulty of live coding I find is to keep aware of the relation between text and sound - this is a balancing act between the ability to change and the ability to understand a certain situation' <span class="citation">(Nilson 2007)</span> While certainly live patching lacks text, there is some critical number of patch cables beyond which it becomes increasingly difficult to keep all the connections in mind. Patch cables turn into a kind of electronic spaghetti, where even the colour codes of my cables are not helpful in comprehending what is connected to what. I attempt to compensate for this by physically tracing my hands along the wires, but even that has its limits. Given the extreme flexibility for feedback and chaos with analogue signals, the routing can become intensely complex. Pd programmers are familiar with a similar effect of a visual spider web forming on screen.</p>
<p>This complexity also leads to a situation analogous to 'crashing', wherein the synthesiser suddenly stops making sounds in performance, in a way that can be difficult to predict. Experimenting with an oscillator's 'hard sync' switch during a set may lead to a sudden and interesting timbre change or a sudden silence. Similarly, long running LFOs can drop below a threshold where they unexpectedly cause things to fall silent. It is often not at all obvious what has caused the sound to stop. In situations where there are a large number of wires and multiple modes of interconnected sound-generation, it can be more beneficial during performance to treat a sudden, unexpected silence as a stopping point and start anew with new sounds after a brief pause to remove cables.</p>
<p>Although it would be impossible to exactly replicate a previous live patch in performance, I do sometimes try to repeat steps that have lead to a 'crash' in past situations, as they make a sudden and final-sounding way to end. I've seen many digital code-based live coders end sets through crashes and at least some of them do court disaster on purpose. Click Nilson has written of the desirability of a '”code out” ending of deliberate coded crash'. <span class="citation">(Nilson 2007)</span> And some live coding languages have embraced crashes as language functionality. ixi lang, for example, has a built-in 'suicide' command, which creates a percentage chance of crashing on each bar. <span class="citation">(Magnusson 2012)</span></p>
<h1 id="toplap-influences"><span class="header-section-number">3</span> TopLap Influences</h1>
<p>Many of the points of similarity above are inherent in live patching, due to a synthesiser's evolution from the analogue computer. However, the courting of crashes is one way in which my practice has been specifically influenced by the live code movement and the TopLap Manifesto in particular. <span class="citation">(TopLap 2010)</span></p>
<h2 id="show-us-your-screens"><span class="header-section-number">3.1</span> Show us your screens</h2>
<p>Like blank slate digital live coders who start positioned behind a laptop with a blank screen, I start with all of my patch cables hung around my neck. Thus we both experience a short pause from starting the set to starting making sound. I also emulate the 'show us your screens' directive, so I turn my synthesiser at an angle to the audience, so the majority of friendly experiencers can see my actions to at least some extent. This orientation is a compromise position such that my instrument is largely visible, but I am not turning my back on the audience. For many lines of sight, it is probably more visible than simply standing in front of the synthesiser. I have experimented also with using a web cam to project a video image of the synthesiser as I patch.</p>
<p>In order to make things more transparent, at the Live Code Festival in Karlsruhe in 2013, I paired this with a manually triggered set of slides of super-imposed text. These started with a description of what colour cable I intended to use for what kind of signal. Copying the Royal Conservatory of the Hague's coding system, I projected that I would be using blue for Control Voltages, black for Audio Voltages and red for Triggers. In addition, I projected the name and a photograph of the module that I was using when plugging into it for the first several connections I made.</p>
<div class="figure">
<img src="images/LFO.JPG" title="LFO" alt="An image I projected in Karlsruhe." /><p class="caption"><em>An image I projected in Karlsruhe.</em></p>
</div>
<p>While audience feedback was generally positive about these good intentions, it was difficult to find a web cam angle that was not blocked by my body as I used the instrument. Even more disappointing, the combined low quality of my web cam and of the projector meant that the different cable colours were not visible to people watching the video display. In low light situations, such as one often has on stage, black cables often become completely invisible. Although a better camera may solve colour issues, I have instead reconsidered what information I should be giving to audiences. Although McLean notes that programmers can take steps such as 'using a language with a simplified syntax, choosing highly descriptive variable names and so on', <span class="citation">(McLean 2008)</span> I have never seen a show-us-your-screens live coder project any explanations as to their syntax colouration or what various commands mean.</p>
<h2 id="graph-changes"><span class="header-section-number">3.2</span> Graph Changes</h2>
<p>When discussing approaches to digital live coding, Magnusson writes,</p>
<blockquote>
<p>The argument . . . is that a true 'liveness' requires that the performer is not simply manipulating pre-written code in real time, but is actually writing and modifying algorithms during the execution of the program. This is arguably a prerequisite of live coding, as simply running code and changing parameters in prewritten code is more comparable to operating buttons, sliders, and knobs on a screen interface or a MIDI controller. <span class="citation">(Magnusson 2014)</span></p>
</blockquote>
<p>This demand for algorithm modification also appears in Collins's live coding analogues, wherein he describes several examples of changing the algorithm mid-play. In one such example, specifically, 'a live-coding twist would be to perturb the algorithm halfway through'. <span class="citation">(Collins 2011)</span> Perhaps, however, it would be useful to take a step back and examine what is meant by 'algorithm' in an analogue context.</p>
<p>Plugging in cables creates a unit generator graph. The output of one circuit is connected to the input of another, eventually creating a complicated sound generation and control process. This is the creation of an algorithm, just as combining unit generators in a patching language creates an algorithm. However, playing this patch, by twiddling knobs on a synthesiser is exactly like operating knobs on a MIDI interface. Indeed, the physical interface is 'pre-written'. This is not to say that a physical interface is necessarily alien to live coding. Marije Baalman's live-coded piece, <em>Wezen-Gewording</em>, uses sensors attached to her hands, to capture the physical gesture of her specifically performative gestures and of her typing code. <span class="citation">(Baalman 2014)</span> However, setting something up and relying solely on parameter changes, while musically valid, is dubious under the heading of 'live coding.' Therefore, Baalman changes her code over the course of the piece. And in my practice, I do not rely on the algorithmic rules established at the start of the set. Instead, I 'perturb the algorithm' by setting up and switching to parallel signal paths.</p>
<h2 id="decisions"><span class="header-section-number">3.3</span> Decisions</h2>
<p>Many computer programs involve decision making. This is not strictly necessary for audio processing, which only needs follow a signal graph. However, I seek to include decision making in my patches, in order to create stronger similarities to coding practice. My synthesiser includes a MOTM 700 voltage controlled router – a module that specifically does binary signal switching based on a comparison of two signals. However, although this module is an obvious choice for seeking to automate some decisions, this kind of behaviour is also found via triggers and envelope generators. When one signal changes, this changes another signal. This seems roughly analogous to an if statement. Because I often use both random generators and FM chaos, I cannot always predict when a trigger will occur. Thus the synthesiser picks up a degree of autonomy and behaves in an unpredictable way, increasing a distance between it and a chainsaw. The instrument may be a tool, but a patch is more like an expression of an idea. <span class="citation">(TopLap 2010)</span></p>
<h2 id="scheduling"><span class="header-section-number">3.4</span> Scheduling</h2>
<p>Many live coding languages offer the possibility of scheduling future events and some have argued that this is therefore a necessary component of live coding or live coding-related practice. In essence, this is a situation where the performer decides to invoke or stop a particular algorithm at a future time. A synthesiser user who wishes to mimic this behaviour has several options, including step sequencers or using LFOs to trigger future events or graph changes. As with deccisions, one can make the timing less predictable by using random generators or chaos. This is not something I tend to use either in my live coding or my live patching practice, but is certainly possible to implement.</p>
<h1 id="conclusion"><span class="header-section-number">4</span> Conclusion</h1>
<p>While discussing live coding metaphorically, McLean wrote, 'We can think of live coding in the sense of working on electricity live, re-routing the flows of control . . ..' <span class="citation">(McLean 2008)</span> In modular synthesiser patching, this practice is not a metaphor. Flows of control are literally plugged and unplugged. Complex systems develop and are replaced by new complex systems. It's no longer necessary to retreat into our imaginations to experience live coding without a computer.</p>

<div class="references">
<p>Baalman, Marije. 2014. “Wezen – Gewording.” Performance; STEIM. <a href="https://www.marijebaalman.eu/?p=404">https://www.marijebaalman.eu/?p=404</a>.</p>
<p>Behrman, David. 1971. “Runthrough.” In <em>Sonic Arts Union</em>. LP; Mainstream Records. <a href="http://www.ubu.com/sound/sau.html">http://www.ubu.com/sound/sau.html</a>.</p>
<p>Cardinali, Lucilla, Francesca Frassinetti, Claudio Brozzoli, Christian Urquizar, Alice C Roy, and Alessandro Farn<span>è</span>. 2009. “Tool-Use Induces Morphological Updating of the Body Schema.” <em>Current Biology</em> 19 (12): R478–R479.</p>
<p>Collins, Nick. 2011. “Live Coding of Consequence.” <em>Leonardo</em> 44 (3): 207–211.</p>
<p>Gresham-Lancaster, Scot. 1998. “The Aesthetics and History of the Hub: the Effects of Changing Technology on Network Computer Music.” <em>Leonardo Music Journal</em>: 39–44.</p>
<p>Griffiths, Dave. 2012. “Scheme Bricks.” <a href="http://github.com/nebogeo/scheme-bricks">http://github.com/nebogeo/scheme-bricks</a>.</p>
<p>Magnusson, Thor. 2011. “Algorithms as Scores: Coding Live Music.” <em>Leonardo Music Journal</em> 21: 19–23.</p>
<p>———. 2014. “Herding Cats: Observing Live Coding in the Wild.” <em>Computer Music Journal</em> 38 (1): 8–16.</p>
<p>———. 2012. “Ixi Lang.” Accessed March 3. <a href="http://www.ixi-audio.net/ixilang/">http://www.ixi-audio.net/ixilang/</a>.</p>
<p>McLean, Alex. 2008. “Live Coding for Free.” <em>Floss+Art. London: OpenMute</em>: 224–231.</p>
<p>Nilson, Click. 2007. “Live Coding Practice.” In <em>Proceedings of the 7th International Conference on New Interfaces for Musical Expression</em>, 112–117. ACM.</p>
<p>Rohrhuber, Julian. 2001. “[Livecode] Analogue Live Coding?” <a href="http://lists.lurk.org/mailman/private/livecode/2011-February/001176.html">http://lists.lurk.org/mailman/private/livecode/2011-February/001176.html</a>.</p>
<p>TopLap. 2010. “ManifestoDraft.” <a href="http://toplap.org/index.php/ManifestoDraft">http://toplap.org/index.php/ManifestoDraft</a>.</p>
</div>
</body>
</html>
